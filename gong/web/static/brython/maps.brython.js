__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1711862011258, "maps": [".py", "from .main import MainMap\nfrom .map import Map\n", ["maps.main", "maps.map"], 1], "maps.main": [".py", "from datetime import datetime,timezone,timedelta\n\nfrom browser import ajax,document,html,window,timer\nimport javascript as js\n\nfrom .map import Map\nfrom stations import sensor_colors,sensor_infos\n\n\nclass MainMap(Map):\n def __init__(\n self,\n center,\n zoom,\n min_zoom,\n lang_code,\n \n ):\n  super().__init__(center,zoom,min_zoom)\n  \n  self.lang_code=lang_code\n  \n  \n  self.sensor_marker_layers={}\n  self.sensor_markers={}\n  self.markers_layer={}\n  \n  self.station_view_url=f\"/{self.lang_code}/stations/\"\n  \n async def render(self):\n  self.map.on(\n  \"click\",lambda ev:print(f\"location: {ev.latlng.lat}, {ev.latlng.lng}\")\n  )\n  \n async def update(self,document_id,data):\n \n \n  if document_id ==\"air4thai\":\n   await self.update_climate_marker(document_id,data)\n  if document_id ==\"airport\":\n   await self.update_climate_marker(document_id,data)\n  if document_id ==\"viir_hotspots\":\n   await self.update_hotspot_marker(document_id,data)\n  if document_id ==\"modis_hotspots\":\n   await self.update_hotspot_marker(document_id,data)\n   \n def remove_all_sensor_marker(self,marker_id):\n \n \n \n  if marker_id in self.sensor_marker_layers.keys():\n   self.map.removeLayer(self.sensor_marker_layers.get(marker_id))\n   \n def set_all_sensor_marker(self,marker_id):\n  if marker_id in self.sensor_marker_layers.keys():\n   self.sensor_marker_layers[marker_id]=self.leaflet.layerGroup(\n   self.markers_layer[marker_id]\n   ).addTo(self.map)\n   \n def on_click_station(self,station_id):\n  url=f\"{self.station_view_url}{station_id}\"\n  \n  window.open(url)\n  \n async def get_sensor_color(self,sensor_type,value):\n  return sensor_colors.get_sensor_color(sensor_type,value)\n  \n async def update_climate_marker(self,source,stations):\n \n \n  markers=[]\n  \n  bangkok_timezone=timezone(timedelta(hours=7),name=\"Asia/Bangkok\")\n  \n  for station in stations[\"stations\"]:\n   animate=True\n   sensor_color=\"DeepSkyBlue\"\n   tooltip_detail=\"\"\n   \n   if station[\"climates\"]:\n   \n    sensor_texts=[]\n    DISPLAY_ORDERS=[\n    sensor_type.lower()\n    for sensor_type in sensor_infos.HTML_SENSOR_NAMES.keys()\n    ]\n    \n    climates=station[\"climates\"].copy()\n    \n    for sensor in station[\"climates\"]:\n     sensor_type=sensor[\"sensor_type\"].lower()\n     if sensor_type not in DISPLAY_ORDERS:\n      DISPLAY_ORDERS.append(sensor_type)\n      \n    for key in DISPLAY_ORDERS:\n     found=False\n     for i,sensor_data in enumerate(climates):\n     \n      if sensor_data[\"sensor_type\"].lower()==key:\n       found=True\n       break\n       \n     if not found:\n      continue\n      \n     sensor=climates.pop(i)\n     sensor_type=sensor[\"sensor_type\"].lower()\n     \n     value=sensor[\"value\"]\n     value_str=f\"{value:.2f}\"if type(value)is float else f\"{value}\"\n     sensor_texts.append(\n     f\"\"\"\n                        {sensor_infos.HTML_SENSOR_NAMES.get(sensor_type, sensor_type)}:\n                        <b>{value_str}</b> {sensor_infos.HTML_SENSOR_UNITS.get(sensor_type,'')}<br/>\n                        \"\"\"\n     )\n     \n    timestamp=datetime.fromisoformat(sensor[\"timestamp\"])\n    ict_date=timestamp.replace(tzinfo=timezone.utc).astimezone(\n    tz=bangkok_timezone\n    )\n    timestamp=timestamp.replace(tzinfo=timezone.utc)\n    \n    tooltip_detail=f\"\"\"\n                    <div align=\"left\" style=\"font-size: 15px;\"> \n                        <b>{station[\"name\"]}</b><br/>\n                        <b>{station[\"name_th\"]}</b><br/>\n                        {''.join(sensor_texts)}\n                        {timestamp.strftime(\"%d/%m/%Y %H:%M:%S %Z\")}<br/>\n                        {ict_date.strftime(\"%d/%m/%Y %H:%M:%S %Z\")}<br/>\n                    </div>\n                    \"\"\"\n   else :\n    animate=False\n    \n    sensor_color=\"DarkGrey\"\n    disactive_txt={\"th\":\"\u0e02\u0e32\u0e14\u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\",\"en\":\"lost connection\"}\n    tooltip_detail=f\"\"\"\n                <div align=\"left\" style=\"font-size: 15px;\"> \n                    <b>{station[\"name\"]}</b><br/>\n                    {disactive_txt[self.lang_code]}\n                </div>\n                \"\"\"\n    \n   sensors={\n   sensor[\"sensor_type\"].lower():sensor[\"value\"]\n   for sensor in station[\"climates\"]\n   }\n   for sensor_type in sensor_infos.HTML_SENSOR_NAMES:\n    if sensor_type in sensors.keys():\n     sensor_color=await self.get_sensor_color(\n     sensor_type,sensors[sensor_type]\n     )\n     break\n   sensor_marker=self.leaflet.icon.pulse(\n   {\n   \"iconSize\":[15,15],\n   \"color\":sensor_color,\n   \"fillColor\":sensor_color,\n   \"animate\":animate,\n   }\n   )\n   \n   marker=self.sensor_markers.get(station[\"id\"],None )\n   if not marker:\n    coordinates=station[\"coordinates\"][\"coordinates\"]\n    marker=(\n    self.leaflet.marker(\n    [coordinates[1],coordinates[0]],\n    {\n    \"customId\":station[\"id\"],\n    \"icon\":sensor_marker,\n    },\n    )\n    .bindTooltip(\n    tooltip_detail,\n    {\"offset\":(0,30),\"className\":\"tooltip-marker\"},\n    )\n    .addTo(self.map)\n    .on(\n    \"click\",\n    lambda e:self.on_click_station(\n    e.sourceTarget.options.customId\n    ),\n    )\n    )\n    \n    markers.append(marker)\n    self.sensor_markers[station[\"id\"]]=marker\n   else :\n    marker.setIcon(sensor_marker)\n    marker.setTooltipContent(tooltip_detail)\n    \n  self.markers_layer[source]=markers\n  \n  layer=self.sensor_marker_layers.get(source)\n  \n  if not layer:\n   print(f\"add layer\",source)\n   self.sensor_marker_layers[source]=self.leaflet.layerGroup(\n   self.markers_layer[source]\n   ).addTo(self.map)\n   \n async def update_hotspot_marker(self,document_id,hotspots):\n \n  markers=[]\n  \n  for hotspot in hotspots[\"hotspots\"]:\n   marker=self.sensor_markers.get(hotspot[\"id\"],None )\n   if not marker:\n    coordinates=hotspot[\"metadata\"][\"coordinates\"][\"coordinates\"]\n    marker=(\n    self.leaflet.circle(\n    [coordinates[1],coordinates[0]],\n    color=\"red\",\n    fillColor=\"#f03\",\n    fillOpacity=0.5,\n    radius=100,\n    )\n    .addTo(self.map)\n    .on(\n    \"click\",\n    lambda e:self.on_click_station(\n    e.sourceTarget.options.customId,\"\"\n    ),\n    )\n    )\n    \n    markers.append(marker)\n    self.sensor_markers[hotspot[\"id\"]]=marker\n    \n  self.markers_layer[document_id]=markers\n  \n  layer=self.sensor_marker_layers.get(document_id)\n  \n  if not layer:\n   print(f\"add layer {document_id} in update map\")\n   self.sensor_marker_layers[document_id]=self.leaflet.layerGroup(\n   self.markers_layer[document_id]\n   ).addTo(self.map)\n", ["browser", "datetime", "javascript", "maps.map", "stations"]], "maps.map": [".py", "from browser import alert,window\n\n\nclass Map:\n def __init__(self,center,zoom,min_zoom):\n  self.center=center\n  self.zoom=zoom\n  self.min_zoom=min_zoom\n  \n  self.shapes={}\n  self.leaflet=window.L\n  \n  self.markers=None\n  self.user_coord=None\n  self.user_mark=[]\n  self.icon_types={\"default\":\"fire\",\"my_location\":\"my_location\"}\n  \n  self.openstreet=self.leaflet.tileLayer(\n  \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n  {\n  \"maxZoom\":19,\n  \"attribution\":\"\"\"&copy;\n                <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors\"\"\",\n  },\n  )\n  self.positron=self.leaflet.tileLayer(\n  \"https://{s}.basemaps.cartocdn.com/rastertiles/light_all/{z}/{x}/{y}.png\",\n  {\n  \"attribution\":\"\"\"&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors,\n                                &copy; <a href=\"http://cartodb.com/attributions\">CartoDB</a>\"\"\",\n  \"subdomains\":\"abcd\",\n  \"maxZoom\":19,\n  },\n  )\n  self.world_imagery=self.leaflet.tileLayer(\n  \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n  {\n  \"maxZoom\":19,\n  \"attribution\":\"\"\"Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye,\n                 Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community\"\"\",\n  },\n  )\n  self.world_topo=self.leaflet.tileLayer(\n  \"\"\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}\"\"\",\n  {\n  \"attribution\":\"\"\"Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap,\n                 iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI,\n                 Esri China (Hong Kong), and the GIS User Community\"\"\"\n  },\n  )\n  self.base_maps={\n  \"<b><span style='color: grey'>Positron</span></b>\":self.positron,\n  \"<b><span style='color: blue'>OpenStreet Map</span></b>\":self.openstreet,\n  \"<b><span style='color: green'>World Map</span></b>\":self.world_imagery,\n  \"<b><span style='color: teal'>World Topo Map</span></b>\":self.world_topo,\n  }\n  \n  container=self.leaflet.DomUtil.get(\"mapid\")\n  if \"leaflet\"in container.className:\n   container._leaflet_id=\"\"\n   \n   \n  self.map=self.leaflet.map(\n  \"mapid\",\n  {\n  \"center\":self.center,\n  \"zoom\":self.zoom,\n  \"min_zoom\":self.min_zoom,\n  \"layers\":self.openstreet,\n  \"renderer\":self.leaflet.canvas({\"padding\":0.5}),\n  \"scrollWheelZoom\":False ,\n  \"smoothWheelZoom\":True ,\n  \"smoothSensitivity\":1,\n  \"zoomControl\":False ,\n  },\n  )\n  self.leaflet.control.zoom({\"position\":\"topright\"}).addTo(self.map)\n  \n  def navi(pos):\n   self.user_coord=(pos.coords.latitude,pos.coords.longitude)\n   self.user_mark=(\n   self.leaflet.marker(\n   self.user_coord,\n   {\"icon\":self.get_icon(\"my_location\"),\"zIndexOffset\":1000},\n   )\n   .addTo(self.map)\n   .bindPopup(\"\u0e15\u0e48\u0e33\u0e41\u0e2b\u0e19\u0e48\u0e07\u0e02\u0e2d\u0e07\u0e04\u0e38\u0e13\")\n   )\n   \n  def nonavi(error):\n   alert(\"Your browser doesn't support geolocation\")\n   \n   \n   \n   \n   \n  self.leaflet.control.layers(self.base_maps).addTo(self.map)\n  \n def __del__(self):\n  self.map.remove()\n  \n def fly_to_user(self):\n  self.map.flyTo(self.user_coord,16)\n  self.user_mark.openPopup()\n  \n def zoom_out(self):\n  self.map.zoomOut(1)\n  \n def zoom_in(self):\n  self.map.zoomIn(1)\n  \n def on_each_feature(self,feature,layer):\n  def zoom_to_feature(e):\n   if self.map.getZoom()<11:\n    self.map.fitBounds(e.target.getBounds())\n    \n  def reset_highlight(e):\n   for key in self.shapes:\n    if self.shapes[key].hasLayer(layer):\n     self.shapes[key].resetStyle(e.target)\n     \n  def highlight_feature(e):\n   layer=e.target\n   \n   layer.setStyle(\n   {\"weight\":2,\"color\":\"black\",\"dashArray\":\"\",\"fillOpacity\":0.8}\n   )\n   \n  layer.on(\n  {\n  \"mouseover\":highlight_feature,\n  \"mouseout\":reset_highlight,\n  \"click\":zoom_to_feature,\n  }\n  )\n  \n def set_shape_with_key(self,data,key):\n  if not data or len(data)==0:\n   return\n   \n  def style(feature):\n   default_color=\"#C6C6C6\"\n   properties=dict(feature.properties)\n   if feature.geometry.type ==\"Point\":\n    default_color=\"#FF6600\"\n   fill_color=properties.get(\"fill\",properties.get(\"color\",default_color))\n   fill_opacity=properties.get(\"fill_opa\",0.3)\n   \n   stroke_w=properties.get(\"stroke_w\",1)\n   stroke_opacity=properties.get(\"stroke_opa\",1)\n   stroke_color=properties.get(\"stroke\",default_color)\n   return {\n   \"fillColor\":fill_color,\n   \"fillOpacity\":fill_opacity,\n   \"color\":stroke_color,\n   \"weight\":stroke_w,\n   \"opacity\":stroke_opacity,\n   }\n   \n  def on_each_feature(feature,layer):\n   def zoom_to_feature(e):\n   \n    if (\n    self.map.getZoom()<11\n    and e.target.feature.geometry.type !=\"Point\"\n    ):\n     self.map.fitBounds(e.target.getBounds())\n     \n   def reset_highlight(e):\n    for key in self.shapes:\n     if self.shapes[key].hasLayer(layer):\n      self.shapes[key].resetStyle(e.target)\n      \n   def highlight_feature(e):\n    layer=e.target\n    \n    layer.setStyle({\"weight\":2,\"fillOpacity\":0.7})\n    \n   popup_detail=\"\"\n   date_txt={\"th\":\"\u0e27\u0e31\u0e19\u0e17\u0e35\u0e48\",\"en\":\"Date\"}\n   zone_txt={\"th\":\"\u0e1e\u0e37\u0e49\u0e19\u0e17\u0e35\u0e48\",\"en\":\"Zone\"}\n   \n   if name :=dict(feature.properties).get(\"Name\"):\n    popup_detail +=f\"<div>{name}</div>\"\n   if des_th :=dict(feature.properties).get(\"DES_TH\"):\n    popup_detail +=f\"<div>{des_th}</div>\"\n   if fire_date :=dict(feature.properties).get(\"DATE\"):\n    popup_detail +=(\n    f\"<div><b>{date_txt[self.lang_code]}</b> : {fire_date}</div>\"\n    )\n   if water_zone :=dict(feature.properties).get(\"Zone\"):\n    popup_detail +=(\n    f\"<div><b>{zone_txt[self.lang_code]}</b> : {water_zone}</div>\"\n    )\n   if acq_date :=dict(feature.properties).get(\"ACQ_DATE\"):\n    popup_detail +=(\n    f\"<div><b>{date_txt[self.lang_code]}</b> : {acq_date}</div>\"\n    )\n    \n   if popup_detail !=\"\":\n    layer.bindPopup(popup_detail)\n    \n   layer.on(\n   {\n   \"mouseover\":highlight_feature,\n   \"mouseout\":reset_highlight,\n   \"click\":zoom_to_feature,\n   }\n   )\n   \n  self.geojson=self.leaflet.geoJson(\n  data,\n  {\n  \"pointToLayer\":lambda feature,latlng:self.leaflet.circle(\n  latlng,\n  {\"radius\":250},\n  ),\n  \"style\":style,\n  \"onEachFeature\":on_each_feature,\n  },\n  ).addTo(self.map)\n  self.shapes[key]=self.geojson\n  \n  if (\n  not self.leaflet.Browser.ie\n  and not self.leaflet.Browser.opera\n  and not self.leaflet.Browser.edge\n  ):\n   self.geojson.bringToFront()\n   \n def set_shape(self,data,color=\"#C6C6C6\"):\n  def style(feature):\n   return {\n   \"fillColor\":color,\n   \"color\":\"#4d4d4d\",\n   \"weight\":1,\n   \"opacity\":1,\n   \"fillOpacity\":0.3,\n   }\n   \n  self.geojson=self.leaflet.geoJson(\n  data,\n  {\n  \"pointToLayer\":lambda feature,latlng:self.leaflet.circle(\n  latlng,{\"radius\":250}\n  ),\n  \"style\":style,\n  \"onEachFeature\":self.on_each_feature,\n  },\n  ).addTo(self.map)\n  \n  \n def get_shape(self):\n  return self.geojson\n  \n def get_icon(self,type=\"default\"):\n  return self.leaflet.icon(\n  dict(\n  iconUrl=f\"/static/resources/marks/{self.icon_types[type]}.svg\",\n  iconSize=[35,35],\n  iconAnchor=[22,40],\n  popupAnchor=[0,-30],\n  )\n  )\n", ["browser"]]}
__BRYTHON__.update_VFS(scripts)
